# Graph Compilation

## Overview

Graph compilation transforms the parsed Manifest into an executable dependency graph. This happens in `Compiler.compile()` ([`core/dbt/compilation.py`](https://github.com/dbt-labs/dbt-core/blob/main/core/dbt/compilation.py)) and produces a `Graph` object wrapping a NetworkX DiGraph.

## Key Classes

### Compiler

- `compile()`: Main entry point. Creates a `Linker`, calls `link_graph()`, optionally adds test edges, writes `graph.gpickle`
- `compile_node()`: Per-node compilation (covered in [Node Compilation](4.4_Node_Compilation.md))

### Linker

Wrapper around `nx.DiGraph` that builds the dependency graph:

- `link_graph()`: Iterates all manifest nodes, calls `link_node()` for each
- `link_node()`: Adds edges based on `node.depends_on_nodes`
- `find_cycles()`: Detects cycles in the graph, raises error if found
- `add_test_edges()`: For `dbt build`, adds edges from tests to downstream nodes

## Graph Structure

- Nodes: unique_ids of all manifest resources (models, tests, seeds, sources, etc.)
- Edges: dependency relationships from `depends_on_nodes`
- Direction: edges point from dependency to dependent (A â†’ B means B depends on A)

## Test Edge Addition

For `dbt build`, tests should block downstream models from executing. The `add_test_edges()` method adds edges from upstream tests to downstream non-test nodes, ensuring tests run before models that depend on the tested resources.

Two implementations exist:
- `add_test_edges_1()`: Original algorithm, comprehensive but adds many redundant edges
- `add_test_edges_2()`: Optimized algorithm (behind `USE_FAST_TEST_EDGES` flag), adds minimal edges

## Cycle Detection

After linking, `find_cycles()` uses NetworkX to detect cycles. If found, raises a `RuntimeError` with the cycle path. This catches circular `ref()` dependencies that would cause infinite loops.
