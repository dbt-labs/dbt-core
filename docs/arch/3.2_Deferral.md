# Deferral

Deferral allows dbt to resolve `ref()` calls to objects that exist in a different environment (typically production) when the referenced model isn't being built in the current run. This is essential for CI workflows where you want to build and test only modified models without rebuilding the entire DAG.

## Overview

When you run `dbt run --select my_model --defer --state prod-artifacts/`, dbt will:

1. Build `my_model` in your target schema
2. For any `ref()` to an unselected model, resolve to the production location instead of the target schema

This enables "slim CI" workflows where only changed models are built, while still being able to reference their unchanged upstream dependencies in production.

## Key Flags

| Flag | Description |
|------|-------------|
| `--defer` | Enable deferral. Resolve unselected refs to the state manifest. |
| `--state PATH` | Path to directory containing production `manifest.json` |
| `--defer-state PATH` | Override state path for deferral only (separate from `--state` used for `state:modified`) |
| `--favor-state` | Always prefer deferred relations for unselected nodes, even if they exist locally |

## How Deferral is Set Up

Deferral is configured during the execution phase, specifically in `GraphRunnableTask.before_run()`:

### 1. Load Previous State

When `--state` or `--defer-state` is provided, `PreviousState` loads the production manifest (`core/dbt/contracts/state.py`):

```python
class PreviousState:
    def __init__(self, state_path: Path, ...):
        manifest_path = self.project_root / self.state_path / "manifest.json"
        writable_manifest = WritableManifest.read_and_check_versions(str(manifest_path))
        self.manifest = Manifest.from_writable_manifest(writable_manifest)
```

### 2. Merge Defer Relations

Before execution, `defer_to_manifest()` is called in `GraphRunnableTask.before_run()`:

```python
def defer_to_manifest(self):
    deferred_manifest = self._get_deferred_manifest()
    if deferred_manifest is None:
        return
    self.manifest.merge_from_artifact(other=deferred_manifest)
```

### 3. The `merge_from_artifact()` Method

This is where the magic happens (`core/dbt/contracts/graph/manifest.py`). For each node in the production manifest that also exists in the current manifest:

```python
def merge_from_artifact(self, other: "Manifest") -> None:
    for unique_id, node in other.nodes.items():
        current = self.nodes.get(unique_id)
        if current and node.resource_type in refables and not node.is_ephemeral:
            defer_relation = DeferRelation(
                database=node.database,
                schema=node.schema,
                alias=node.alias,
                relation_name=node.relation_name,
                # ... other metadata
            )
            self.nodes[unique_id] = replace(current, defer_relation=defer_relation)
```

This attaches a `defer_relation` attribute to each node, containing the production database/schema/alias where that node exists.

## The `DeferRelation` Object

`DeferRelation` (`core/dbt/artifacts/resources/v1/components.py`) is a lightweight object that captures the production location of a node:

- `database`: Production database name
- `schema`: Production schema name
- `alias`: Production table/view name
- `relation_name`: Fully-qualified relation name
- `compiled_code`: The production compiled SQL (for reference)
- `meta`, `tags`, `config`: Metadata from production

## How Refs are Resolved with Deferral

See [Node Compilation â€” Deferred Ref Resolution](4.4_Node_Compilation.md#deferred-ref-resolution) for how `ref()` calls use the `defer_relation` during compilation.

## `--favor-state` Behavior

By default, deferral only applies when the referenced relation doesn't exist in the target environment (checked via adapter cache lookup). With `--favor-state`:

- Unselected nodes **always** resolve to their `defer_relation`
- Even if the local relation exists, production is preferred
- Useful when you want strict isolation from local state

## Use Cases

### Slim CI

```bash
dbt run --select state:modified+ --defer --state prod-run-artifacts/
```

Only build modified models and their descendants, referencing production for everything else.

### Development with Production Data

```bash
dbt run --select my_new_model --defer --state prod-run-artifacts/ --favor-state
```

Develop a new model that references production tables, without rebuilding upstream models locally.

### Clone with Deferral

```bash
dbt clone --select my_model --defer --state prod-run-artifacts/
```

Clone specific models from production to a development schema.
