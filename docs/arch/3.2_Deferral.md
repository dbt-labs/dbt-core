# Deferral

Deferral allows dbt to resolve `ref()` calls to objects that exist in a different environment (typically production) when the referenced model isn't being built in the current run. This is essential for CI workflows where you want to build and test only modified models without rebuilding the entire DAG.

## Overview

When you run `dbt run --select my_model --defer --state prod-artifacts/`, dbt will:

1. Build `my_model` in your target schema
2. For any `ref()` to an unselected model, resolve to the production location instead of the target schema

This enables "slim CI" workflows where only changed models are built, while still being able to reference their unchanged upstream dependencies in production.

## Key Flags

| Flag | Description |
|------|-------------|
| `--defer` | Enable deferral. Resolve unselected refs to the state manifest. |
| `--state PATH` | Path to directory containing production `manifest.json` |
| `--defer-state PATH` | Override state path for deferral only (separate from `--state` used for `state:modified`) |
| `--favor-state` | Always prefer deferred relations for unselected nodes, even if they exist locally |

## How Deferral is Set Up

Deferral is configured during the execution phase, specifically in `GraphRunnableTask.before_run()`:

### 1. Load Previous State

When `--state` or `--defer-state` is provided, dbt creates a `PreviousState` object that loads the production `manifest.json` from the specified path. This manifest is deserialized and version-checked to ensure compatibility with the current dbt version.

### 2. Merge Defer Relations

Before execution begins, `GraphRunnableTask.before_run()` calls `defer_to_manifest()`. This method retrieves the deferred manifest (loaded from the state path) and merges it into the current manifest.

### 3. Attaching Defer Relations to Nodes

The merge process iterates through every node in the production manifest. For each node that also exists in the current manifest and is a refable resource type (not ephemeral), dbt creates a `DeferRelation` object containing the production location metadata: database, schema, alias, and fully-qualified relation name. This `DeferRelation` is then attached to the corresponding node in the current manifest.

After this merge, each eligible node carries information about where it exists in production, which can be used later during ref resolution if that node is not selected for execution.

## The `DeferRelation` Object

`DeferRelation` (`core/dbt/artifacts/resources/v1/components.py`) is a lightweight object that captures the production location of a node:

- `database`: Production database name
- `schema`: Production schema name
- `alias`: Production table/view name
- `relation_name`: Fully-qualified relation name
- `compiled_code`: The production compiled SQL (for reference)
- `meta`, `tags`, `config`: Metadata from production

## How Refs are Resolved with Deferral

See [Node Compilation â€” Deferred Ref Resolution](4.4_Node_Compilation.md#deferred-ref-resolution) for how `ref()` calls use the `defer_relation` during compilation.

## `--favor-state` Behavior

By default, deferral only applies when the referenced relation doesn't exist in the target environment (checked via adapter cache lookup). With `--favor-state`:

- Unselected nodes **always** resolve to their `defer_relation`
- Even if the local relation exists, production is preferred
- Useful when you want strict isolation from local state

## Use Cases

### Slim CI

```bash
dbt run --select state:modified+ --defer --state prod-run-artifacts/
```

Only build modified models and their descendants, referencing production for everything else.

### Development with Production Data

```bash
dbt run --select my_new_model --defer --state prod-run-artifacts/ --favor-state
```

Develop a new model that references production tables, without rebuilding upstream models locally.

### Clone with Deferral

```bash
dbt clone --select my_model --defer --state prod-run-artifacts/
```

Clone specific models from production to a development schema.
