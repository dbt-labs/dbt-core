# Node Selection

## Overview

Node selection determines which nodes from the manifest will be executed based on `--select` and `--exclude` arguments. The selection framework lives in `core/dbt/graph/`.

## Selection Syntax

### Basic Selectors

- `model_name`: Select by name
- `tag:value`: Select by tag
- `path:models/staging`: Select by file path
- `package:my_package`: Select by package
- `config.materialized:view`: Select by config value
- `state:modified`: Select modified nodes (requires `--state`, see below)

### Graph Operators

- `+model`: Select model and all ancestors
- `model+`: Select model and all descendants  
- `+model+`: Select model, ancestors, and descendants
- `@model`: Select model, ancestors, descendants, and tests of ancestors

### Set Operations

- `model_a model_b`: Union (space-separated)
- `model_a,model_b`: Union (comma-separated)
- `--exclude model_c`: Exclusion

## Key Classes

### SelectionSpec / SelectionCriteria

Parsed representation of selection arguments. `parse_difference()` in `core/dbt/graph/cli.py` parses CLI arguments into a `SelectionSpec`.

### SelectorMethod

Base class for selector implementations. Each selector type (tag, path, config, etc.) has a corresponding method class in `core/dbt/graph/selector_methods.py`.

### NodeSelector

Main class for resolving selection specs against the graph:

- `select_nodes()`: Recursively resolves selection spec, applies set operations
- `get_nodes_from_criteria()`: Resolves a single criterion, applies graph operators
- `expand_selection()`: Handles indirect test selection
- `filter_selection()`: Final filtering (e.g., by resource type)

### ResourceTypeSelector

Extends `NodeSelector` to filter by `NodeType`. The `node_is_match()` method checks if a node's resource type is in the allowed set.

## State-Based Selection

The `state:modified` selector is designed for CI/CD workflows where you want to run only the resources that have changed between two project states, allowing you to detect potential regressions without running the entire project. This requires the `--state` flag pointing to a directory containing a previous manifest (typically from production).

### How Modification Detection Works

The `StateSelectorMethod` in `core/dbt/graph/selector_methods.py` compares each node in the current manifest against its counterpart in the previous state's manifest. Each resource type implements a `same_contents()` method that encodes the semantic comparison logic for that resource type. This method returns `True` if the node is considered unchanged, and `False` if it should be marked as modified.

The `same_contents()` comparison typically checks:
- `raw_code` / `raw_sql`: The source SQL or Python code
- `config`: Materialization, schema, tags, and other configuration
- `depends_on`: References to other nodes (`ref()`, `source()`)
- Resource-specific fields: e.g., `columns` for sources, `test_metadata` for tests

### State Selector Variants

- `state:modified`: Nodes where `same_contents()` returns `False`
- `state:new`: Nodes that exist in current manifest but not in previous state
- `state:modified.body`: Only code changes (ignores config changes)
- `state:modified.configs`: Only config changes

## Indirect Selection

Tests can be selected indirectly when their parent models are selected. Modes:

- **eager** (default): Select test if ANY parent is selected
- **cautious**: Select test only if ALL parents are selected
- **buildable**: Select test if all parents are selected or are ancestors of selected nodes
- **empty**: Don't expand to tests

## GraphQueue Construction

`NodeSelector.get_graph_queue()` creates the execution queue:

1. `get_selected()`: Get final set of selected node IDs
2. `full_graph.get_subset_graph()`: Create subgraph with only selected nodes
3. `GraphQueue(subgraph, ...)`: Wrap in thread-safe queue with topological ordering
