# dbt retry

## Overview

`dbt retry` re-executes failed nodes from the previous run. It reads the `run_results.json` artifact to determine which nodes failed and runs them using the same command and flags from the original invocation.

**Reference**: https://docs.getdbt.com/reference/commands/retry

## Task Class: `RetryTask`

`RetryTask` extends `ConfiguredTask` and dynamically creates the appropriate task for the original command based on `run_results.json`.

```python
class RetryTask(ConfiguredTask):
    def __init__(self, args, config):
        # Load previous run results
        self.previous_results = load_result_state(
            Path(config.project_root) / Path(state_path) / "run_results.json"
        )
        
        # Determine which command was run
        self.previous_command_name = self.previous_args.get("which")
        self.task_class = TASK_DICT.get(self.previous_command_name)
```

## Implementation Quirks

### Supported Commands

Only certain commands are retryable:

```python
TASK_DICT = {
    "build": BuildTask,
    "compile": CompileTask,
    "clone": CloneTask,
    "generate": GenerateTask,
    "seed": SeedTask,
    "snapshot": SnapshotTask,
    "test": TestTask,
    "run": RunTask,
    "run-operation": RunOperationTask,
}
```

### Retryable Statuses

Nodes with these statuses are retried:

```python
RETRYABLE_STATUSES = {
    NodeStatus.Error,
    NodeStatus.Fail,
    NodeStatus.Skipped,
    NodeStatus.RuntimeErr,
    NodeStatus.PartialSuccess,  # Microbatch partial failure
}
```

### Flag Merging

Retry combines previous flags with current CLI arguments:

Flags are merged as follows:

1. **From previous run**: Most flags are restored (e.g., `--select`, `--full-refresh`, `--defer`)
2. **Always from current invocation**: Path-related flags (`--profiles-dir`, `--project-dir`, `--target-path`, `--log-path`) and `--warn-error`
3. **CLI override allowed**: `--vars` and `--threads` can be overridden if explicitly passed on the command line

### Dynamic Task Wrapping

Retry creates a wrapper class that overrides the original Task's `get_graph_queue()`:

```python
class TaskWrapper(self.task_class):
    def get_graph_queue(self):
        new_graph = self.graph.get_subset_graph(unique_ids)
        return GraphQueue(new_graph.graph, self.manifest, unique_ids)
```

### Microbatch Batch-Level Retry

For microbatch models, retry only re-runs failed batches by passing a `batch_map` to the `RunTask`.

### Operation Node Filtering

`run-operation` results aren't retried if not retrying `dbt run-operation` directly.

### `--warn-error` Interaction

If `--warn-error` is set for retry, warnings from previous runs become failures:

```python
if args.warn_error:
    RETRYABLE_STATUSES.add(NodeStatus.Warn)
```

### Late Manifest Parsing

Unlike most commands, retry parses the manifest inside the task after resolving flags:

```python
# Parse manifest using resolved config/flags
manifest = parse_manifest(retry_config, ...)
```

## Flags

| Flag | Description |
|------|-------------|
| `--state` | Override path to previous run results |
| `--threads` | Override thread count |
| `--vars` | Override variables |
| `--full-refresh` | Force full refresh for incremental models |

## Use Cases

1. **CI Recovery**: Re-run failed nodes after fixing issues
2. **Transient Failures**: Retry after network/database hiccups
3. **Partial Deployments**: Complete interrupted runs
4. **Microbatch Resumption**: Continue from failed batch

## Example Flow

```bash
# Original run fails on 3 models
dbt run --select tag:nightly

# Fix the issues, then retry just the failures
dbt retry

# Or retry with different parallelism
dbt retry --threads 1
```
