# Node Compilation

## Overview

Node compilation renders Jinja templates into executable SQL. This happens in `Compiler.compile_node()` (`core/dbt/compilation.py`) and is invoked by Runners during execution.

### Example: Before and After Compilation

**Before (raw SQL with Jinja)** — `models/marts/orders_with_payments.sql`:

```sql
{{
  config(
    materialized='table',
    schema='marts'
  )
}}

with orders as (
    select * from {{ ref('stg_orders') }}
),

payments as (
    select * from {{ source('stripe', 'payments') }}
)

select
    orders.order_id,
    orders.customer_id,
    orders.order_date,
    payments.amount
from orders
left join payments on orders.payment_id = payments.id
```

**After (compiled SQL)** — `target/compiled/my_project/models/marts/orders_with_payments.sql`:

```sql
with orders as (
    select * from "database"."staging"."stg_orders"
),

payments as (
    select * from "database"."stripe"."payments"
)

select
    orders.order_id,
    orders.customer_id,
    orders.order_date,
    payments.amount
from orders
left join payments on orders.payment_id = payments.id
```

The `config()` block is processed during parsing (setting node properties like `materialized='table'`) and stripped from the compiled output. The `ref()` and `source()` calls are resolved to fully-qualified database relations based on the target environment's configuration.

## Key Methods

### Compiler.compile_node()

Main entry point for per-node compilation:

1. Calls `_compile_code()` to render Jinja → `compiled_code`
2. Calls `_recursively_prepend_ctes()` for ephemeral model CTE injection
3. Writes compiled SQL to `target/compiled/` directory

### _compile_code()

Renders the node's `raw_code` using Jinja:

1. Creates node context via `_create_node_context()`
2. Calls `jinja.render()` with the context
3. Sets `node.compiled_code` and `node.compiled = True`

### _create_node_context()

Builds the Jinja rendering context:

- For regular nodes: `generate_runtime_model_context()`
- For unit tests: `generate_runtime_unit_test_context()`
- Adds test kwargs for generic tests

## Ephemeral Model Handling

Ephemeral models don't create database objects—they're injected as CTEs into referencing models.

### _recursively_prepend_ctes()

When a model references an ephemeral model via `ref()`:

1. The ephemeral model is added to `node.extra_ctes` during parsing
2. During compilation, `_recursively_prepend_ctes()` compiles each ephemeral dependency
3. Recursively processes nested ephemeral references
4. Injects compiled SQL as CTEs at the beginning of the referencing model's SQL

### CTE Injection

The `_inject_ctes_into_sql()` method prepends CTEs to the model's SQL:

```sql
WITH __dbt__cte__ephemeral_model AS (
  -- compiled SQL from ephemeral model
),
-- any additional CTEs from the model itself
SELECT * FROM __dbt__cte__ephemeral_model
```

## Compilation vs Parsing

Key distinction (see [Parsing vs Compilation vs Runtime](../guides/parsing-vs-compilation-vs-runtime.md)):

- **Parsing**: Extract structure, resolve refs, no Jinja rendering
- **Compilation**: Render Jinja, produce `compiled_code`, inject CTEs
- **Runtime**: Execute against database

Compilation requires adapter connection for `run_query()` in Jinja. It happens during Task execution, not during manifest loading.
