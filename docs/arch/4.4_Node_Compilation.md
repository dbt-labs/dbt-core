# Node Compilation

## Overview

Node compilation renders Jinja templates into executable SQL. This happens in `Compiler.compile_node()` ([`core/dbt/compilation.py`](https://github.com/dbt-labs/dbt-core/blob/main/core/dbt/compilation.py)) and is invoked by Runners during execution.

### Example: Before and After Compilation

**Before (raw SQL with Jinja)** — `models/marts/orders_with_payments.sql`:

```sql
{{
  config(
    materialized='table',
    schema='marts'
  )
}}

with orders as (
    select * from {{ ref('stg_orders') }}
),

payments as (
    select * from {{ source('stripe', 'payments') }}
)

select
    orders.order_id,
    orders.customer_id,
    orders.order_date,
    payments.amount
from orders
left join payments on orders.payment_id = payments.id
```

**After (compiled SQL)** — `target/compiled/my_project/models/marts/orders_with_payments.sql`:

```sql
with orders as (
    select * from "database"."staging"."stg_orders"
),

payments as (
    select * from "database"."stripe"."payments"
)

select
    orders.order_id,
    orders.customer_id,
    orders.order_date,
    payments.amount
from orders
left join payments on orders.payment_id = payments.id
```

The `config()` block is processed during parsing (setting node properties like `materialized='table'`) and stripped from the compiled output. The `ref()` and `source()` calls are resolved to fully-qualified database relations based on the target environment's configuration.

## Key Methods

### Compiler.compile_node()

Main entry point for per-node compilation:

1. Calls `_compile_code()` to render Jinja → `compiled_code`
2. Calls `_recursively_prepend_ctes()` for ephemeral model CTE injection
3. Writes compiled SQL to `target/compiled/` directory

### _compile_code()

Renders the node's `raw_code` using Jinja:

1. Creates node context via `_create_node_context()`
2. Calls `jinja.render()` with the context
3. Sets `node.compiled_code` and `node.compiled = True`

### _create_node_context()

Builds the Jinja rendering context:

- For regular nodes: `generate_runtime_model_context()`
- For unit tests: `generate_runtime_unit_test_context()`
- Adds test kwargs for generic tests

## Ephemeral Model Handling

Ephemeral models don't create database objects—they're injected as CTEs into referencing models.

### _recursively_prepend_ctes()

When a model references an ephemeral model via `ref()`:

1. The ephemeral model is added to `node.extra_ctes` during parsing
2. During compilation, `_recursively_prepend_ctes()` compiles each ephemeral dependency
3. Recursively processes nested ephemeral references
4. Injects compiled SQL as CTEs at the beginning of the referencing model's SQL

### CTE Injection

The `_inject_ctes_into_sql()` method prepends CTEs to the model's SQL:

```sql
WITH __dbt__cte__ephemeral_model AS (
  -- compiled SQL from ephemeral model
),
-- any additional CTEs from the model itself
SELECT * FROM __dbt__cte__ephemeral_model
```

## Deferred Ref Resolution

When deferral is enabled (`--defer`), `ref()` calls may resolve to production relations instead of the target schema. This happens in `RuntimeRefResolver.create_relation()` ([`core/dbt/context/providers.py`](https://github.com/dbt-labs/dbt-core/blob/main/core/dbt/context/providers.py)).

The resolution logic checks three conditions:

1. **Node has a `defer_relation`**: Set during `merge_from_artifact()` (see [Deferral](3.2_Deferral.md))
2. **`--defer` flag is enabled**
3. **One of**:
   - `--favor-state` is set AND the node is not in the current selection
   - OR the relation doesn't exist in the target environment (adapter cache lookup)

```python
if (
    target_model.defer_relation
    and self.config.args.defer
    and (
        (self.config.args.favor_state and target_model.unique_id not in SELECTED_RESOURCES)
        or not get_adapter(self.config).get_relation(database, schema, identifier)
    )
):
    # Use defer_relation (production) instead of target_model (local)
    return self.Relation.create_from(self.config, target_model.defer_relation, ...)
```

### Example

With `--defer --state prod-artifacts/`:

```sql
-- Source: models/marts/report.sql
select * from {{ ref('dim_customers') }}

-- If dim_customers is NOT selected and exists in prod:
-- Compiles to: select * from "prod_db"."prod_schema"."dim_customers"

-- If dim_customers IS selected (being built in this run):
-- Compiles to: select * from "dev_db"."dev_schema"."dim_customers"
```

## Compilation vs Parsing

Key distinction (see [Parsing vs Compilation vs Runtime](../guides/parsing-vs-compilation-vs-runtime.md)):

- **Parsing**: Extract structure, resolve refs, no Jinja rendering
- **Compilation**: Render Jinja, produce `compiled_code`, inject CTEs
- **Runtime**: Execute against database

Compilation requires adapter connection for `run_query()` in Jinja. It happens during Task execution, not during manifest loading.
