# dbt build

## Overview

`dbt build` runs all seeds, models, snapshots, and tests in DAG order. It's the "do everything" command that respects dependencies across resource types.

**Reference**: https://docs.getdbt.com/reference/commands/build

## Task Class: `BuildTask`

`BuildTask` extends `RunTask` and adds multi-resource-type execution with test edges in the graph.

### Key Differences from `RunTask`

1. **Multiple Resource Types**: Handles seeds, models, snapshots, tests, unit tests, saved queries, exposures, and functions via `RUNNER_MAP`
2. **Test Edges**: Calls `compiler.compile(manifest, add_test_edges=True)` to add edges from tests to downstream nodes
3. **Unit Test Handling**: Runs unit tests *before* their associated model (see below)

### RUNNER_MAP

```python
RUNNER_MAP = {
    NodeType.Model: ModelRunner,
    NodeType.Snapshot: SnapshotRunner,
    NodeType.Seed: SeedRunner,
    NodeType.Test: TestRunner,
    NodeType.Unit: TestRunner,
    NodeType.SavedQuery: SavedQueryRunner,
    NodeType.Exposure: ExposureRunner,
    NodeType.Function: FunctionRunner,
}
```

## Implementation Quirks

### Test Edge Injection

The `add_test_edges=True` flag adds graph edges that ensure tests run at the right time:
- Tests run *after* all their parent nodes complete
- If a test fails, downstream nodes are skipped

This differs from `dbt run` + `dbt test` where either models or tests are run, but not both resource types.

### Unit Test Ordering

Unit tests run *before* their associated model, not after. This is handled specially:

1. `get_graph_queue()` builds `model_to_unit_test_map` mapping model IDs to their unit tests
2. When a model is dequeued, `handle_model_with_unit_tests_node()` runs unit tests first
3. If any unit test fails, the model itself is skipped, via `call_model_and_unit_tests_runner()`

### Node Count Adjustment

Because unit tests aren't in the main graph queue but are run inline with their models, `BuildTask` adjusts `num_nodes` in `handle_job_queue()`:

```python
if self.run_count == 0:
    self.num_nodes = self.num_nodes + len(self.selected_unit_tests)
```

### Failure Propagation

`BuildTask.MARK_DEPENDENT_ERRORS_STATUSES` determines which statuses cause downstream skips:

```python
MARK_DEPENDENT_ERRORS_STATUSES = [
    NodeStatus.Error,
    NodeStatus.Fail,
    NodeStatus.Skipped,
    NodeStatus.PartialSuccess,  # microbatch partial failure
]
```

### Two-Pass Node Selection

To correctly count nodes and handle unit tests, `get_graph_queue()` runs selection twice:
1. With unit tests, in order to identify selected unit tests
2. Without unit testsâ€”to build the actual execution queue

The difference is stored in `self.selected_unit_tests`.

## Flags

| Flag | Description |
|------|-------------|
| `--select` | Select nodes to build |
| `--exclude` | Exclude nodes from build |
| `--resource-type` | Filter by resource type (model, seed, snapshot, test) |
| `--full-refresh` | Treat incremental models as full refreshes |
| `--store-failures` | Store test failures in the database |
