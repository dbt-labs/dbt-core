# Task Framework

The `Task` framework provides the execution layer that coordinates running dbt commands. It establishes a layered architecture where `Task`s handle command-level orchestration, `Runner`s handle per-node execution, and `Selector`s manage graph-based node selection and queuing.

## Task Hierarchy

Tasks are organized in a class hierarchy that adds capabilities at each level. The base classes live in [`core/dbt/task/base.py`](https://github.com/dbt-labs/dbt-core/blob/main/core/dbt/task/base.py) and [`core/dbt/task/runnable.py`](https://github.com/dbt-labs/dbt-core/blob/main/core/dbt/task/runnable.py).

```
BaseTask
 ├── CleanTask
 ├── DebugTask
 ├── DepsTask
 ├── InitTask
 └── ConfiguredTask
      ├── RetryTask
      ├── RunOperationTask
      ├── ServeTask
      └── GraphRunnableTask
           ├── CloneTask
           ├── ListTask
           └── CompileTask
                ├── GenerateTask
                ├── ShowTask
                └── RunTask
                     ├── BuildTask
                     ├── FreshnessTask
                     ├── SeedTask
                     ├── SnapshotTask
                     └── TestTask
```

### BaseTask

The abstract base class for all tasks. It holds `args: Flags` and defines the `run()` abstract method that each task must implement. Simple commands like `dbt clean`, `dbt debug`, `dbt deps`, and `dbt init` inherit directly from `BaseTask` since they don't require project configuration or manifest access.

### ConfiguredTask

Extends `BaseTask` with project awareness. Adds `config: RuntimeConfig`, `manifest: Manifest`, and a `Compiler` instance. The `compile_manifest()` method invokes graph compilation (see [Graph Compilation](4.2_Graph_Compilation.md)), producing a `Graph` object. Commands that need project context but don't execute nodes against the graph (like `dbt run-operation`) inherit from this level.

### GraphRunnableTask

The main workhorse for DAG-based execution. Manages the full execution lifecycle: node selection, thread pool management, and result collection. Key methods include:

- `_runtime_initialize()`: Compiles the manifest and builds the `GraphQueue` via `get_graph_queue()`
- `get_node_selector()`: Returns a `NodeSelector` (or subclass) for resolving `--select`/`--exclude` arguments
- `execute_nodes()`: Creates a thread pool and drives `run_queue()`
- `run_queue()`: Pulls nodes from the queue and dispatches them to `call_runner()`
- `call_runner()`: Invokes the Runner for a single node, handles results and error propagation

The `run()` method orchestrates the full flow: `_runtime_initialize()` → `execute_with_hooks()` → result writing.

### CompileTask

Specializes `GraphRunnableTask` for compilation-focused commands. Sets `raise_on_first_error()` to `True` and uses `CompileRunner` for all nodes. The `get_node_selector()` returns a `ResourceTypeSelector` filtering to executable node types.

`CompileTask` also supports inline SQL compilation via the `--inline` flag (e.g., `dbt compile --inline "select * from {{ ref('my_model') }}"`). This allows users to compile arbitrary SQL strings that use dbt Jinja functions like `ref()` and `source()` without needing a corresponding model file. The inline SQL is parsed into a temporary `SqlOperation` node, added to the manifest, compiled, and then removed after execution.

### RunTask and BuildTask

`RunTask` extends `CompileTask` for model execution, adding hook execution (`on-run-start`, `on-run-end`), schema creation, and model-specific result tracking. It uses `ModelRunner` for models and handles microbatch incremental models specially.

`BuildTask` extends `RunTask` to process multiple resource types in a single invocation. It maintains a `RUNNER_MAP` dispatching each `NodeType` to the appropriate Runner, and overrides `compile_manifest()` to add test edges to the graph (see [Graph Compilation](4.2_Graph_Compilation.md)).

## Runner Hierarchy

Runners handle per-node execution. The base class lives in `core/dbt/task/base.py`, with specialized runners in their respective task modules.

```
BaseRunner
 ├── CloneRunner
 ├── FreshnessRunner
 ├── SavedQueryRunner
 └── CompileRunner
      ├── ShowRunner
      ├── TestRunner
      ├── GenericSqlRunner
      │    ├── SqlCompileRunner
      │    └── SqlExecuteRunner
      └── ModelRunner
           ├── SeedRunner
           └── SnapshotRunner
```

### BaseRunner

Abstract base for per-node execution. Holds references to `config`, `adapter`, `node`, and a `Compiler` instance. Key methods:

- `run_with_hooks()`: Entry point called by the Task. Invokes `before_execute()`, `safe_run()`, `after_execute()`
- `safe_run()`: Wraps `compile_and_execute()` with error handling and connection management
- `compile_and_execute()`: The core two-phase execution—compiles the node, then executes it (for non-ephemeral nodes)
- `compile()`: Abstract method implemented by subclasses to compile the node
- `execute()`: Abstract method implemented by subclasses to execute the compiled node

### CompileRunner

Basic compilation runner. The `compile()` method calls `compiler.compile_node()` (see [Node Compilation](4.4_Node_Compilation.md)). The `execute()` method simply returns a success result without running SQL and is used for `dbt compile`.

### ModelRunner

Executes models by invoking materialization macros. The `execute()` method generates a runtime context, looks up the appropriate materialization macro, and invokes it via `MacroGenerator`. The materialization macro handles all adapter interactions (see [Node Materialization](4.5_Node_Materialization.md)).

### TestRunner

Executes tests (data tests and unit tests). For data tests, it runs the test SQL and interprets row counts as pass/fail. For unit tests, it sets up fixtures, runs the model, and compares actual vs expected results.

## Node Selection

Node selection determines which nodes from the manifest will be executed. The selector framework lives in `core/dbt/graph/`.

### NodeSelector

The main class for resolving selection specs against the compiled graph. Given a `SelectionSpec` (parsed from `--select`/`--exclude` arguments), it traverses the graph to find matching nodes, applies graph operators (`+`, `@`), and handles indirect selection for tests. The `get_selected()` method returns the final set of unique IDs. See [Node Selection](4.3_Node_Selection.md) for details on selection syntax and methods.

### ResourceTypeSelector

Extends `NodeSelector` to filter by `NodeType`. Used by most commands to restrict selection to relevant resource types (e.g., `RunTask` selects only models, `TestTask` selects only tests).

### GraphQueue

A thread-safe priority queue backed by the dependency graph. Nodes are scored by topological depth (lower depth = higher priority). The queue tracks in-progress nodes and releases downstream nodes only when their dependencies complete via `mark_done()`. This ensures correct execution order while maximizing parallelism.

## Execution Flow

The typical execution flow for a graph-based command:

1. **Task.run()**: Entry point, sets up context
2. **_runtime_initialize()**: Calls `compile_manifest()` to build the `Graph`, then `get_graph_queue()` for node selection
3. **execute_with_hooks()**: Gets adapter, calls `before_run()`, `execute_nodes()`, `after_run()`
4. **execute_nodes()**: Creates `DbtThreadPool`, calls `run_queue()`
5. **run_queue()**: Loop pulling nodes from `GraphQueue`, dispatching to thread pool via `call_runner()`
6. **call_runner()**: Creates Runner via `get_runner()`, invokes `runner.run_with_hooks()`
7. **Runner.run_with_hooks()** → **safe_run()** → **compile_and_execute()**: Compiles node, executes it, returns `RunResult`
8. **_handle_result()**: Records result, marks dependent nodes as skipped if needed
9. **GraphQueue.mark_done()**: Releases downstream nodes

Results are collected in `node_results` and written to `run_results.json` at the end of execution.
