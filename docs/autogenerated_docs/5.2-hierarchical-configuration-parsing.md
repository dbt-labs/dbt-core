# Hierarchical Configuration Parsing

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [.changes/unreleased/Fixes-20250612-145159.yaml](https://github.com/dbt-labs/dbt-core/blob/64b58ec6/.changes/unreleased/Fixes-20250612-145159.yaml)

</details>



## Purpose and Scope

This document covers dbt-core's hierarchical configuration parsing system, which manages how configuration values are resolved across multiple levels of the project hierarchy. The system handles configuration precedence, inheritance, and overrides for settings like `store_failures`, test configurations, and other model properties.

For information about project-level configuration schemas, see [Project Configuration and Schema](#5.1). For general configuration validation, see [Configuration Validation and JSON Schema](#3.1).

## Overview

dbt-core implements a hierarchical configuration system that allows configurations to be defined at multiple levels and resolved according to precedence rules. This enables flexible configuration management where settings can be defined broadly at the project level and selectively overridden at more specific levels.

```mermaid
graph TB
    subgraph "Configuration Hierarchy"
        PL["dbt_project.yml<br/>(Project Level)"]
        DL["Directory Configs<br/>(Directory Level)"]
        ML["Model/Test Configs<br/>(Node Level)"]
    end
    
    subgraph "Parsing Engine"
        HP["HierarchicalConfigParser"]
        CR["ConfigResolver"]
        VM["ValueMerger"]
    end
    
    subgraph "Configuration Types"
        SF["store_failures"]
        TC["TestConfigs"]
        MC["ModelConfigs"]
        SC["SourceConfigs"]
    end
    
    PL --> HP
    DL --> HP
    ML --> HP
    
    HP --> CR
    CR --> VM
    
    VM --> SF
    VM --> TC
    VM --> MC
    VM --> SC
```

*Sources: .changes/unreleased/Fixes-20250612-145159.yaml*

## Configuration Levels and Precedence

The hierarchical configuration parsing system resolves configurations across multiple levels, with more specific levels taking precedence over general ones:

| Level | Scope | Configuration Source | Precedence |
|-------|--------|---------------------|------------|
| Project | Global | `dbt_project.yml` | Lowest |
| Directory | Path-based | Directory-level configs | Medium |
| Node | Individual models/tests | In-file configs, schema.yml | Highest |

### Configuration Resolution Process

```mermaid
flowchart TD
    Start["Configuration Request"] --> LoadProject["Load Project Config<br/>(dbt_project.yml)"]
    LoadProject --> LoadDirectory["Load Directory Config<br/>(if applicable)"]
    LoadDirectory --> LoadNode["Load Node Config<br/>(model/test specific)"]
    LoadNode --> Merge["Merge Configurations<br/>(Hierarchical Resolution)"]
    Merge --> Validate["Validate Final Config"]
    Validate --> Return["Return Resolved Config"]
    
    subgraph "Merge Process"
        BaseConfig["Base: Project Config"]
        OverrideDir["Override: Directory Config"]
        OverrideNode["Override: Node Config"]
        
        BaseConfig --> OverrideDir
        OverrideDir --> OverrideNode
    end
```

*Sources: .changes/unreleased/Fixes-20250612-145159.yaml*

## Store Failures Configuration Example

The `store_failures` configuration demonstrates hierarchical parsing behavior. This configuration can be defined at multiple levels and needs proper precedence resolution:

### Configuration Levels for store_failures

```mermaid
graph LR
    subgraph "Project Level"
        ProjSF["dbt_project.yml:<br/>tests:<br/>  +store_failures: true"]
    end
    
    subgraph "Model/Test Level" 
        ModelSF["Individual Test:<br/>config:<br/>  store_failures: false"]
    end
    
    subgraph "Resolution"
        Resolver["ConfigResolver"]
        FinalSF["Final Value:<br/>store_failures: false<br/>(node-level override)"]
    end
    
    ProjSF --> Resolver
    ModelSF --> Resolver
    Resolver --> FinalSF
```

### Common Issues and Fixes

The hierarchical parsing system has encountered issues with proper precedence resolution, particularly with the `store_failures` configuration:

**Issue #10165**: Fix for `store_failures` hierarchical config parsing ensures that node-level configurations properly override project-level defaults.

*Sources: .changes/unreleased/Fixes-20250612-145159.yaml*

## Implementation Architecture

The hierarchical configuration parsing system integrates with dbt-core's broader configuration validation framework:

```mermaid
graph TB
    subgraph "Input Sources"
        DBT_PROJECT["dbt_project.yml"]
        SCHEMA_FILES["schema.yml files"]
        MODEL_CONFIGS["Model in-file configs"]
    end
    
    subgraph "Parsing Layer"
        PROJECT_PARSER["ProjectConfigParser"]
        SCHEMA_PARSER["SchemaParser"]
        CONFIG_PARSER["ConfigParser"]
    end
    
    subgraph "Resolution Engine"
        HIERARCHY_RESOLVER["HierarchyResolver"]
        PRECEDENCE_ENGINE["PrecedenceEngine"]
        CONFIG_MERGER["ConfigMerger"]
    end
    
    subgraph "Validation"
        JSON_VALIDATOR["JSONSchemaValidator"]
        TYPE_CHECKER["TypeChecker"]
        CONSTRAINT_VALIDATOR["ConstraintValidator"]
    end
    
    DBT_PROJECT --> PROJECT_PARSER
    SCHEMA_FILES --> SCHEMA_PARSER
    MODEL_CONFIGS --> CONFIG_PARSER
    
    PROJECT_PARSER --> HIERARCHY_RESOLVER
    SCHEMA_PARSER --> HIERARCHY_RESOLVER
    CONFIG_PARSER --> HIERARCHY_RESOLVER
    
    HIERARCHY_RESOLVER --> PRECEDENCE_ENGINE
    PRECEDENCE_ENGINE --> CONFIG_MERGER
    
    CONFIG_MERGER --> JSON_VALIDATOR
    JSON_VALIDATOR --> TYPE_CHECKER
    TYPE_CHECKER --> CONSTRAINT_VALIDATOR
```

*Sources: .changes/unreleased/Fixes-20250612-145159.yaml*

## Configuration Merging Strategies

The system employs different merging strategies depending on the configuration type:

| Configuration Type | Merge Strategy | Behavior |
|-------------------|----------------|----------|
| Simple Values | Override | Later values completely replace earlier ones |
| Lists | Append/Override | Configurable - either append or replace |
| Dictionaries | Deep Merge | Recursive merging of nested structures |
| Boolean Flags | Override | Direct replacement (e.g., `store_failures`) |

### Deep Merge Example

For complex configurations, the system performs deep merging to combine settings from different levels while preserving granular overrides.